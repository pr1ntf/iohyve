#!/bin/sh

# Set ZFS properties
__zfs_set() {
	shift 1
	if [ $# -lt 2 ]; then
		printf "missing argument\nusage:\n"
		printf "\tset <property=value> ... <name>\n"
		exit 1
	fi

	local name="$(echo "$@" | rev | cut -d' ' -f1 | rev)"
	local dataset="$(zfs get -H -s local -o name,value -t filesystem iohyve:name | grep "$(printf '\t')$name$" | cut -f1)"

	local var=0
	for arg in "$@"; do
		# Increment loop counter
		var=$(($var+1))
		# Exit if last loop iteration is reached
		if [ $var -eq $# ]; then
			exit 0
		fi
		if [ -z "$(echo "$arg" | grep =)" ]; then
			printf "missing value for '$arg'\nusage:\n"
			printf "\tset <property=value> ... <name>\n"
			exit 1
		fi
		local prop="$(echo "$arg" | cut -d '=' -f1)"
		local val="$(echo "$arg" | cut -d '=' -f2)"
		if [ $prop = "bargs" ]; then
			local sval="$(echo $val | cut -d '"' -f2 | sed -e 's/ /_/g')"
			zfs set iohyve:$prop=$sval $dataset
		elif [ $prop = "description" ]; then
			local sval="$(echo $val | cut -d '"' -f2)"
			zfs set "iohyve:$prop=$sval" $dataset
		else
			zfs set iohyve:$prop=$val $dataset
		fi
	done
}

# Get ZFS props
__zfs_get() {
	local prop="$2"
	local name="$3"

	if [ $prop = "all" ]; then
		__zfs_getall $name
		exit
	fi

	if [ -z $name ]; then
		printf "missing argument\nusage:\n"
		printf "\tget <prop> <name>\n"
		exit 1
	fi
	
	local dataset="$(zfs get -H -s local -o name,value -t filesystem iohyve:name | grep "$(printf '\t')$name$" | cut -f1)"

	(
	printf "%s^%s^%s\n" "NAME" "PROPERTY" "VALUE"
	printf "%s^%s^%s\n" $name $prop "$(zfs get -H -o value iohyve:$prop $dataset)"
	) | column -ts^
}

# Remove a PCIDEV property
__zfs_rmpci() {
	local flagone="$2"
	local flagtwo="$3"
	local flagthree="$4"
	if [ $flagone = "-f" ]; then
		if [ -z $flagthree ]; then
			printf "missing argument\nusage:\n"
			printf "\trmpci [-f] <name> <pcidev:N>\n"
			exit 1
		fi
		echo "Removing $flagthree from $flagtwo"
		local pciprop="$(echo "$flagthree" | grep pcidev:)"
		local dataset="$(zfs get -H -s local -o name,value -t filesystem iohyve:name | grep "$(printf '\t')$flagtwo$" | cut -f1)"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			zfs inherit  -r iohyve:$flagthree $dataset
		fi
	else
		if [ -z $flagtwo ]; then
			printf "missing argument\nusage:\n"
			printf "\trmpci [-f] <name> <pcidev:N>\n"
			exit 1
		fi
		local pciprop="$(echo "$flagtwo" | grep pcidev:)"
		local dataset="$(zfs get -H -s local -o name,value -t filesystem iohyve:name | grep "$(printf '\t')$flagone$" | cut -f1)"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			read -p "Are you sure you want to remove $flagtwo [Y/N]? " an </dev/tty
			case "$an" in
				y|Y) zfs inherit  -r iohyve:$flagtwo $dataset
				;;
				*) echo "Not removed..."
				;;
			esac
		fi
	fi
}

# Get all ZFS props
__zfs_getall() {
	local guests="$1"
	# If no guest specified, use all
	if [ -z $guests ]; then
		guests="$(zfs get -H -s local -o value iohyve:name)"
	fi
	(
	printf "%s^%s^%s\n" "NAME" "PROPERTY" "VALUE"
	for guest in $guests; do
		local dataset="$(zfs get -H -s local -o name,value -t filesystem iohyve:name | grep "$(printf '\t')$guest$" | cut -f1)"
		printf "%s\n" "$(zfs get -H -o property,value all $dataset | grep iohyve: | sort | tr '\t' '^' | sed -e "s/iohyve:/$guest^/g")"
	done
	) | column -ts^
}

# Snapshot a guest
__zfs_snapguest() {
	local fullsnap="$2"
	local name="$(echo $fullsnap | cut -d '@' -f1)"
	local snapname="$(echo $fullsnap | cut -d '@' -f2)"
	if [ -z $name ] || [ -z "$(echo $fullsnap | grep '@')" ]; then
		printf "missing argument\nusage:\n"
		printf "\tsnap <name>@<snap>\n"
		exit 1
	fi
	local dataset="$(zfs get -H -s local -o name,value -t filesystem iohyve:name | grep "$(printf '\t')$name$" | cut -f1)"
	echo "Taking snapshot $fullsnap"
	# Check if guest exists
	if [ ! -z $dataset ]; then
		zfs snap -r $dataset@$snapname
	else
		echo "Not a valid guest name"
	fi
}

# Rollback guest
__zfs_rollguest() {
	local fullsnap="$2"
	local name="$(echo $fullsnap | cut -d '@' -f1)"
	local dataset="$(zfs get -H -s local -o name,value -t filesystem iohyve:name | grep "$(printf '\t')$name$" | cut -f1)"
	local snap="$(echo $fullsnap | cut -d '@' -f2)"
	if [ -z $snap ] || [ -z "$(echo $fullsnap | grep '@')" ]; then
		printf "missing argument\nusage:\n"
		printf "\troll <name>@<snap>\n"
		exit 1
	fi
	local disks="$(zfs list -H -r -t volume -o name $dataset)"
	# Check if guest exists
	echo "Rolling back to $fullsnap"
	if [ ! -z $dataset ]; then
		# Check to make sure guest isn't running
		local running=$(pgrep -fx "bhyve: ioh-$name")
		if [ -z $running ]; then
			zfs rollback -rR $dataset@$snap
			for disk in $disks ; do
				zfs rollback -rR $disk@$snap
			done
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Clone a guest
__zfs_cloneguest() {
	local flag="$2"
	local name="$2"
	local cname="$3"
	if [ "$flag" == "-r" ]; then
		name="$3"
		cname="$4"
	fi

	if [ -z $cname ]; then
		printf "missing argument\nusage:\n"
		printf "\tclone <name> <clonename>\n"
		exit 1
	fi

	local description="$(date | sed -e 's/ /_/g')"
	local dataset="$(zfs get -H -s local -o name,value -t filesystem iohyve:name | grep "$(printf '\t')$name$" | cut -f1)"
	local datasetpath="$(echo $dataset | rev | cut -d/ -f2- | rev)"
	# Check if guest exists
	echo "Cloning $name to $cname"
	if [ ! -z $dataset ]; then
		# Take snapshot
		zfs snap -r $dataset@$cname
		# zfs send that snap and desendants then receive to cname
		zfs send -R $dataset@$cname | \
		zfs recv $datasetpath/$cname
		# clean up
		zfs destroy -rR $dataset@$cname
		zfs destroy -rR $datasetpath/$cname@$cname
		# rename the guest
		zfs set iohyve:name=$cname $datasetpath/$cname
		zfs set iohyve:description=$description $datasetpath/$cname
		# change con and tap properties to next available if -r is specified
		if [ "$flag" == "-r" ]; then
			local taplast="$(zfs get -H -o value -s local iohyve:tap | sort -V | cut -c4- | tail -n1)"
			if [ -z $taplast ]; then
				local tap='0'
			else
				local tap="$(expr $taplast + 1)"
			fi
			local conlast="$(zfs get -H -o value -s local iohyve:con | sort -V | cut -c5- | tail -n1)"
			if [ -z $conlast ]; then
				local con='0'
			else
				local con="$(expr $conlast + 1)"
			fi

			zfs set iohyve:tap=tap$tap $datasetpath/$cname
			zfs set iohyve:con=nmdm$con $datasetpath/$cname
		fi
	else
		echo "'$name' is not a valid guest name"
	fi
}

# Export Guest
__zfs_exportguest() {
	local name="$2"
	if [ -z $name ]; then
		printf "missing argument\nusage:\n"
		printf "\texport <name>\n"
		exit 1
	fi
	local dataset="$(zfs get -H -s local -o name,value -t filesystem iohyve:name | grep "$(printf '\t')$name$" | cut -f1)"
	local mountpoint="$(zfs get -H -o value mountpoint $dataset)"
	local disks="$(zfs list -H -r -t volume -o name $dataset)"
	# Check if guest exists
	echo "Exporting $name. Note this may take some time depending on the size."
	if [ ! -z $dataset ]; then
		# Check to make sure guest isn't running
		local running=$(pgrep -fx "bhyve: ioh-$name")
		if [ -z $running ]; then
			# Create /tmp/iohyve/$name
			echo "Creating temp directory..."
			mkdir -p /tmp/iohyve/$name
			# Export Properties to file
			echo "Exporting properties..."
			zfs get -H -o property,value all $dataset | grep iohyve: | sort | \
				sed -e 's/iohyve://g' | sed -e 's/	/=/g' > /tmp/iohyve/$name/properties.ucl
			# Write disks to file
			echo "Exporting disks..."
			for disk in $disks ; do
				local diskname="$(echo $disk | rev | cut -d/ -f1  | rev)"
				dd if=/dev/zvol/$disk of=/tmp/iohyve/$name/${diskname}.img bs=1M
			done
			# Compress and add to archive
			echo "Compressing to archive..."
			tar -czf $mountpoint/$name.tar.gz -C /tmp/iohyve/$name/ .
			# Remove /tmp/iohyve/
			echo "Removing temp directory..."
			rm -fr /tmp/iohyve
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# List all the snapshots
__zfs_snaplist() {
	zfs list -H -t snap | grep iohyve | grep -v disk | cut -f1 | cut -d '/' -f3
}

# Get PCI device config from zfs
__zfs_get_pcidev_conf() {
	local pool="$1"
	local oldifs=$IFS
	#local pci
	IFS=$'\n'
	for pcidev in $(zfs get -H -o property,value all $pool | grep iohyve:pcidev: | sort )
	do
		echo $pcidev | cut -f2-
	done
	IFS=$oldifs
}
